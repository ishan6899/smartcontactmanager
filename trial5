import {Component, ElementRef, Input, ViewChild} from '@angular/core';
import * as d3 from 'd3'
import { Network, DataSet } from 'vis';


interface Node {
  id: number|string;
  name: string;
  parents: number[];
  children: number[];
}




@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css']
})
export class AppComponent {
  nodes: Node[] = [
    {id: 1, name: 'Parent 1', parents: [], children: [3]},
    {id: 2, name: 'Parent 2', parents: [], children: [3, 4]},
    {id: 3, name: 'Child 1', parents: [1, 2], children: [5]},
    {id: 4, name: 'Child 2', parents: [2], children: []},
    {id: 5, name: 'Child 3', parents: [3], children: []},
  ];
  links = [
    {source: 0, target: 2},
    {source: 1, target: 2},
    {source: 1, target: 3},
    {source: 2, target: 4}
  ]
  @ViewChild('graph', {static: true})
  private graph!:any;

  ngOnInit() {
    const container = this.graph.nativeElement;
    const nodes = ([
      {id: 1, label: 'Node 1',hello:1},
      {id: 2, label: 'Node 2'},
      {id: 3, label: 'Node 3'},
      {id: 4, label: 'Node 4'},
      {id: 5, label: 'Node 5'},
      {id: 6, label: 'Node 6'}

    ]);

    const edges = new DataSet<any>([
      {from: 1, to: 3},

      {from: 1, to: 2},
      {from: 2, to: 4},
      {from: 2, to: 5},
      {from:6,to:2}
    ]);
    const data = { nodes, edges };
    const options = {
      nodes: {
        font: {
          size: 22
        },
        borderWidth: 3
      },
      edges: {
        font: {
          align: "top"
        },
        smooth: {
          type: "dynamic",
          forceDirection: "horizontal",
          roundness: 0.0
        },
        arrows: {
          to: { enabled: true, scaleFactor: 1, type: "arrow" }
        }
      },
      layout: {
        hierarchical: {
          direction: "LR",
          sortMethod: 'directed'
        }
      },
      interaction: {
        tooltipDelay: 200,
        hover: true
      },
      physics: {
        "barnesHut": {
          "springConstant": 0,
          "avoidOverlap": 0.2
        }
      }
    };
    this.graph = new Network(container, <any>data, <any>options);
// Compute the distinct nodes from the // Assuming you receive the Java object as 'javaObject' from the API response

// Create an empty array to store nodes and edges
const nodes = [];
const edges = [];

// Function to recursively traverse the hierarchy and populate nodes and edges
function traverseHierarchy(obj) {
  // Create a unique ID for the current node
  const nodeId = obj.name + '_' + Math.random().toString(36).substr(2, 9);

  // Add the current node to the 'nodes' array
  nodes.push({ id: nodeId, label: obj.name });

  // Process the 'down' list
  if (obj.down && obj.down.length > 0) {
    obj.down.forEach(downObj => {
      // Create an ID for the downstream node
      const downNodeId = downObj.name + '_' + Math.random().toString(36).substr(2, 9);

      // Add the edge from current node to downstream node
      edges.push({ from: nodeId, to: downNodeId });

      // Recursively traverse the downstream hierarchy
      traverseHierarchy(downObj);
    });
  }

  // Process the 'up' list
  if (obj.up && obj.up.length > 0) {
    obj.up.forEach(upObj => {
      // Create an ID for the upstream node
      const upNodeId = upObj.name + '_' + Math.random().toString(36).substr(2, 9);

      // Add the edge from upstream node to current node
      edges.push({ from: upNodeId, to: nodeId });

      // Recursively traverse the upstream hierarchy
      traverseHierarchy(upObj);
    });
  }
}

// Start traversing the hierarchy with the received Java object
traverseHierarchy(javaObject);

// Now you have the nodes and edges in the desired format
console.log(nodes);
console.log(edges);

// You can then use 'nodes' and 'edges' in your graph visualization library, such as vis.js, to display the graph


import { Component, OnInit } from '@angular/core';

@Component({
  selector: 'app-graph-component',
  template: `
    <!-- Your graph visualization HTML template goes here -->
  `,
})
export class GraphComponent implements OnInit {
  javaObject: any; // Assuming you have the Java object assigned to this variable

  nodes: any[] = [];
  edges: any[] = [];

  ngOnInit() {
    // Start traversing the hierarchy with the received Java object
    this.traverseHierarchy(this.javaObject);

    // Now you have the nodes and edges in the desired format
    console.log(this.nodes);
    console.log(this.edges);

    // You can then use 'this.nodes' and 'this.edges' in your graph visualization library to display the graph
  }

  // Function to recursively traverse the hierarchy and populate nodes and edges
  traverseHierarchy(obj: any) {
    // Create a unique ID for the current node
    const nodeId = obj.name + '_' + Math.random().toString(36).substr(2, 9);

    // Add the current node to the 'nodes' array
    this.nodes.push({ id: nodeId, label: obj.name });

    // Process the 'down' list
    if (obj.down && obj.down.length > 0) {
      obj.down.forEach((downObj: any) => {
        // Create an ID for the downstream node
        const downNodeId = downObj.name + '_' + Math.random().toString(36).substr(2, 9);

        // Add the edge from current node to downstream node
        this.edges.push({ from: nodeId, to: downNodeId });

        // Recursively traverse the downstream hierarchy
        this.traverseHierarchy(downObj);
      });
    }

    // Process the 'up' list
    if (obj.up && obj.up.length > 0) {
      obj.up.forEach((upObj: any) => {
        // Create an ID for the upstream node
        const upNodeId = upObj.name + '_' + Math.random().toString(36).substr(2, 9);

        // Add the edge from upstream node to current node
        this.edges.push({ from: upNodeId, to: nodeId });

        // Recursively traverse the upstream hierarchy
        this.traverseHierarchy(upObj);
      });
    }
  }
}


